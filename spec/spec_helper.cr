require "spec"
require "../src/myst/**"

include Myst

# Run the Myst parser on the given source code, returning the AST that the
# parser generates for it.
def parse_program(source : String) : AST::Node
  parser = Parser.new(IO::Memory.new(source), __DIR__)
  program = parser.parse_block
end

# Run the given source through the Myst interpreter. The result of
# this function is a tuple of IOs: output and errput.
def run_program(source : String) : Tuple(IO, IO, Interpreter)
  program = parse_program(source)
  interpreter = Myst::Interpreter.new
  program.accept(interpreter)
  return {STDOUT, STDERR, interpreter}
end

# Return the list of tokens generated by lexing the given source. Parsing is
# not performed, so semantically-invalid sequences are allowed by this method.
def tokenize(source : String)
  parser = Parser.new(IO::Memory.new(source), __DIR__)
  parser.lex_all
  parser.tokens
end

# Assert that the given source causes a syntax error
def assert_syntax_error(source : String)
  expect_raises(SyntaxError) do
    tokenize(source)
  end
end

# Assert that given source is accepted by the parser. The given source will not
# be executed by this method.
# Currently, this method just invokes the parser to ensure no errors occur.
def assert_valid(source)
  parse_program(source)
end

# Inverse of `assert_valid`: Assert that the given source causes a ParseError.
def assert_invalid(source)
  expect_raises(ParseError) do
    parse_program(source)
  end
end

# Assert that the value on the top of the stack after interpreting the given
# program matches the given value.
def assert_value(source, expected)
  stack = run_program(source)[2].stack
  stack.last.should be(expected)
end

# Similar to `assert_value`, but implicitly expect the value on the top of the
# stack to be a TBoolean that is `true`.
def assert_true(source)
  stack = run_program(source)[2].stack
  stack.last.should be(TBoolean.new(true))
end

# Similar to `assert_true`, but only check for truthiness, not that the value
# is necessarily a boolean.
def assert_truthy(source)
  stack = run_program(source)[2].stack
  stack.last.truthy?.should eq(true)
end

# Run the given source and assert that the output from running the program
# matches the given expectation exactly.
def assert_output(source, expected)
  output, _, _ = run_program(source)
  output.should eq(expected)
end

# Same as `assert_output`, but for error output.
def assert_error(source, expected)
  _, errput, _ = run_program(source)
  errput.should eq(expected)
end

# A less strict version of `assert_output`, only asserting that the output
# contains the given expectation somewhere in its content.
def assert_output_contains(source, expected)
  output, _, _ = run_program(source)
  output.should contain(expected)
end

def assert_error_contains(source, expected)
  output, _, _ = run_program(source)
  output.should contain(expected)
end
